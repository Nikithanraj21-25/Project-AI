# -*- coding: utf-8 -*-
"""fake/real-news-classification.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ik37L2NqFS4BlO-RV0KVfkd_h1wZfWtQ

### **Import Required Libraries**
"""

from sklearn.naive_bayes import MultinomialNB
from sklearn.feature_extraction.text import CountVectorizer

from sklearn.model_selection import train_test_split
from sklearn import metrics
import matplotlib.pyplot as plt

import pandas as pd
import numpy as np
import itertools

"""### **Import Dataset**"""

df = pd.read_csv('fake_or_real_news.csv')

"""### **Data Summarization**"""

df.shape

df.head(5)

df = df.set_index('Unnamed: 0')

df.head(5)

"""### **Segregation of Input and Output**"""

#output
y = df.label
print(y)

#input
x = df.drop('label',axis=1)
print(x)

"""### **Splitting Dataset into Train Data and Test Data**"""

x_train, x_test, y_train, y_test = train_test_split(x['text'], y, test_size=0.33, random_state=53)

count_vectorizer = CountVectorizer(stop_words='english')
count_train = count_vectorizer.fit_transform(x_train)
count_test = count_vectorizer.transform(x_test)

count_vectorizer.get_feature_names_out()[:10]

count_df = pd.DataFrame(count_train.A, columns = count_vectorizer.get_feature_names_out())
print(count_df)

count_df.head()

def plot_confusion_matrix(cm, classes,
                          normalize=False,
                          suptitle='Confusion Matrix',
                          cmap=plt.cm.Blues):
  plt.imshow(cm, interpolation='nearest', cmap=cmap)
  plt.title(suptitle)
  plt.colorbar()
  tick_marks = np.arange(len(classes))
  plt.xticks(tick_marks, classes)
  plt.yticks(tick_marks, classes)

  if normalize:
    cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
    print("Normalized Confusion Matrix")
  else:
    print('Confusion matrix, without normalization')

  thresh = cm.max()/2
  for i,j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
    plt.text(j,i,cm[i,j],
             horizontalalignment="center",
             color="white" if cm[i,j] > thresh else "black")

  plt.tight_layout()
  plt.ylabel('True label')
  plt.xlabel('Predicted label')
  plt.show()

model = MultinomialNB()

model.fit(count_train, y_train)

pred = model.predict(count_test)
score = metrics.accuracy_score(y_test, pred)
print("accuracy : %0.3f"% score)

cm = metrics.confusion_matrix(y_test, pred, labels=['FAKE', "REAL"])
print(cm)
plot_confusion_matrix(cm, classes=['FAKE', 'REAL'])

myText = input("enter the input text: ")

countvec_test = count_vectorizer.transform([myText])

pred = model.predict(countvec_test)
print(pred)
